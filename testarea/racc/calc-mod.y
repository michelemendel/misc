
# simple calc parser

class Calcp

  convert
    AND '&&'
  end

  prechigh
    left 'AND' 'OR'
  preclow

rule

  target: exp
        | /* none */ { result = "" }
        ;
  exp: exp 'AND' exp { result << val[2]  }
     | exp 'OR' exp { result << val[2] }
     | '(' exp ')' { result << val[1] }
     | TOKEN
     ;

end


---- header ----

# calc.rb : generated by racc

---- inner ----
  
  def parse( str )
    @q = []

    while str.size > 0 do
      case str
      when /\A.+/o
        @q.push [:TOKEN, $&]
      end
      str = $'
    end
    @q.push [false, '$end']

    do_parse
  end

  def next_token
    @q.shift
  end


---- footer ----

parser = Calcp.new
count = 0
scnt  = 0

puts
puts 'type "Q" to quit.'
puts

while true do
  puts
  print '? '
  str = gets.chop!
  break if /q/i === str

  begin
    val = parser.parse( str )
    print '=> ', val, "\n"
  rescue ParseError
    puts $!
  rescue
    puts 'unexpected error ?!'
    raise
  end

end
